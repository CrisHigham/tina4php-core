#!/usr/bin/env php
<?php
$replacePath = $argv[0]; //used to figure out where we're running
global $rootPath;
global $session; //store things here you want to reuse
$session = [];

foreach (get_included_files() as $id => $file) {
    if (strpos($file, "vendor" . DIRECTORY_SEPARATOR . "autoload.php")) {
        $rootPath = str_ireplace("vendor" . DIRECTORY_SEPARATOR . "autoload.php", "", $file);
        break;
    }
}

if (empty($rootPath)) {
    $rootPath = str_replace("vendor" . DIRECTORY_SEPARATOR . "tina4stack" . DIRECTORY_SEPARATOR . "tina4php-core" . DIRECTORY_SEPARATOR . "bin" . DIRECTORY_SEPARATOR . "tina4service", "", __FILE__);
    $rootPath = str_replace("bin" . DIRECTORY_SEPARATOR . "tina4service", "", $rootPath);
}

require_once "{$rootPath}vendor/autoload.php";
define("TINA4_SUPPRESS", true);

if (file_exists($rootPath . "index.php")) {
    include_once $rootPath . "index.php";
}

$stopFileName = "{$rootPath}stop";
if (file_exists($stopFileName)) {
    unlink($stopFileName);
}

\Tina4\Debug::message("Running from folder {$rootPath}", TINA4_LOG_INFO);
\Tina4\Debug::message("Running Tina4 service", TINA4_LOG_INFO);

//Garbage collection
gc_enable();

while (TRUE && !file_exists($stopFileName)) {
    $service = new \Tina4\Service();
    sleep($service->getSleepTime());
    $processes = $service->getProcesses();
    if (!empty($processes)) {
        foreach ($processes as $id => $process) {
            try {
                if (get_class($process) !== "__PHP_Incomplete_Class") {
                    try {
                        //How to know we are not on server?
                        if (TINA4_DEBUG) {
                            \Tina4\Debug::message("Running {$process->name}", TINA4_LOG_INFO);

                            $reflection = new \ReflectionClass(get_class($process));
                            $code = file_get_contents($reflection->getFileName());
                            $code = str_replace('<?php', '', $code);
                            $aliasNumber = rand(1000, 9999);

                            if (isset($settings[$process->name]) && $settings[$process->name]["hash"] == md5($code)) {
                                $aliasNumber = $settings[$process->name]["instance"];
                            } else {
                                $settings[$process->name]["hash"] = md5($code);
                                $settings[$process->name]["instance"] = $aliasNumber;

                                //Works when name space is used
                                $className = explode(DIRECTORY_SEPARATOR, get_class($process));
                                $className = $className[count($className) - 1];

                                $code = str_replace($className, $className . $aliasNumber, $code);
                                //Load new class
                                \Tina4\Debug::message(date("Y-m-d H:i:s") . " Reloading code for service {$className} \n{$code}", TINA4_LOG_DEBUG);
                                eval($code);
                            }

                            eval('$runner = new ' . get_class($process) . $aliasNumber . "('{$process->name}');");
                            if (timeToRun($process)){
                                if ($runner->canRun()) {
                                    \Tina4\Debug::message(date("Y-m-d H:i:s") . " Running {$process->name}", TINA4_LOG_DEBUG);
                                    $runner->run();
                                }
                            }

                            unset ($runner);
                            $runner = null;
                        } else {
                            if (timeToRun($process)){
                                if ($process->canRun()) {
                                    \Tina4\Debug::message(date("Y-m-d H:i:s") . " Running {$process->name}");
                                    $process->run();
                                }
                            }
                            unset($process);
                        }
                    }
                    catch (\Exception $exception)
                    {
                        \Tina4\Debug::message("Exception happened in service:\n".$exception->getMessage());
                    }

                    gc_collect_cycles();
                } else {
                    \Tina4\Debug::message("Could not load registered process, make sure it is in one of the TINA4_INCLUDE_LOCATIONS", TINA4_LOG_DEBUG);
                }
            } catch (Exception $exception) {
                \Tina4\Debug::message(date("Y-m-d H:i:s") . " Could not run " . $exception->getMessage(), TINA4_LOG_DEBUG);
            }
        }
    } else {
        \Tina4\Debug::message(date("Y-m-d H:i:s") . " Nothing found to run", TINA4_LOG_DEBUG);
    }
    //clean up
    unset($service);
}

/**
 * Function to add timing interval functionality to the service runner.
 * Is backward compatible and if not used, will continue standard runs every TINA4_SERVICE_TIME
 * Compares the given process timing parameters (based on linux crons) against the current time to determine if it needs to run.
 * Uses a file named timer_ProcessName.dat stored in the bin folder to ensure it only runs once per timing window.
 * This is necessary due to the services sleep timer.
 * CAUTION: For this to work adequately the services sleep timer should probably be set to less than 50 seconds to avoid missing timed runs
 * CAUTION: This should never be used for accurate timing as it could be upto TINA4_SERVICE_TIME seconds delayed
 *  Accepts wild card '*' - runs on every timing
 *  Accepts interval '*\/5' - runs every 5 units of timing. Note backslash not included is an escape here
 *  Accepts list '1,4,34,57' - runs every given unit of timing
 *  Accepts value '3' - runs on the given unit of timing
 * @param \Tina4\Process $process
 * @return bool
 */
function timeToRun(Tina4\Process $process): bool
{
    // if no process timing has been used then return true every time
    // This defaults to the standard services timing set by TINA4_SERVICE_TIME
    $processTime = $process->timing;
    if (empty($processTime)){

        return true;
    }

    // set the current timing
    $dt = new DateTime();
    $currentTiming[0] = (int) $dt->format('i');   // minute
    $currentTiming[1] = (int) $dt->format('G');     // hour
    $currentTiming[2] = (int) $dt->format('j');      // day
    $currentTiming[3] = (int) $dt->format('n');    // month
    $currentTiming[4] = (int) $dt->format('w');  // weekday

    if (file_exists("bin" . DIRECTORY_SEPARATOR . "timing_" . $process->name . ".dat")){
        // Check if the current time fits in the processing time window
        // As the service can technically run every second. There might be a number of times that fit in the processing time window.
        $processTiming = explode(" ", $processTime);
        $processEqualsCurrent = true;
        for ($i = 0; $i < 5; $i++) {
            if (!fieldMatches($processTiming[$i], $currentTiming[$i])) {
                $processEqualsCurrent = false;
            }
        }

        if ($processEqualsCurrent) {
            // If we are here, it means we are ready to run. The Current time is a Process Time
            // We need to ensure that the Process Time does not match the last Process Time, ie it has just run.
            $lastTime = file_get_contents("bin" . DIRECTORY_SEPARATOR . "timing_" . $process->name . ".dat");
            $lastTiming = explode(" ", $lastTime);
            $processEqualsLast = true;
            for ($i = 0; $i < 5; $i++) {
                if (!fieldMatches($processTiming[$i], $lastTiming[$i])) {
                    $processEqualsLast = false;
                }
            }
            if ($processEqualsLast) {
                // The process has already run once in this process window

                return false;
            } else {
                // The process has not run in this process window and should run
                setLastTime($currentTiming, $process);

                return true;
            }
        } else {
            // The process is not timed to run. Update the last time
            setLastTime($currentTiming, $process);

            return false;
        }

    } else {
        // set the lastTime as a baseline for the next process run
        setLastTime($currentTiming, $process);

        return false;
    }
}

/**
 * Function to set a time stamp. Used to ensure a service does not run more than once in a time window.
 * @param array $currentTiming
 * @param \Tina4\Process $process
 * @return void
 */
function setLastTime(array $currentTiming, Tina4\Process $process): void
{
    $lastTime = implode(" ", $currentTiming);
    // save the timing file
    file_put_contents("bin" . DIRECTORY_SEPARATOR . "timing_" . $process->name . ".dat", $lastTime);
}

/**
 * Function compares two timings against each other checking if the declared processTime is suitable at the given time
 * @param string $processField
 * @param int $timingField
 * @return bool
 */
function fieldMatches(string $processField, int $timingField): bool
{
    if ($processField === '*') {
        return true;
    }

    // Interval match (e.g., */5)
    if (preg_match('/^\*\/(\d+)$/', $processField, $matches)) {
        $step = (int)$matches[1];
        return $timingField % $step === 0;
    }

    // List match (e.g., 1,2,3)
    if (strpos($processField, ',') !== false) {
        $values = explode(',', $processField);
        return in_array((string)$timingField, $values, true);
    }

    // Exact value
    return (int)$processField === $timingField;
}